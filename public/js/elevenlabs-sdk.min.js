(() => {
  // node_modules/@11labs/client/dist/lib.umd.js
  !function(e, n) {
    "object" == typeof exports && "undefined" != typeof module ? n(exports) : "function" == typeof define && define.amd ? define(["exports"], n) : n((e || self).client = {});
  }(void 0, function(e) {
    function n() {
      return n = Object.assign ? Object.assign.bind() : function(e2) {
        for (var n2 = 1; n2 < arguments.length; n2++) {
          var t2 = arguments[n2];
          for (var o2 in t2) ({}).hasOwnProperty.call(t2, o2) && (e2[o2] = t2[o2]);
        }
        return e2;
      }, n.apply(null, arguments);
    }
    function t(e2) {
      for (var n2 = window.atob(e2), t2 = n2.length, o2 = new Uint8Array(t2), r2 = 0; r2 < t2; r2++) o2[r2] = n2.charCodeAt(r2);
      return o2.buffer;
    }
    function o(e2, n2) {
      try {
        var t2 = e2();
      } catch (e3) {
        return n2(e3);
      }
      return t2 && t2.then ? t2.then(void 0, n2) : t2;
    }
    var r = /* @__PURE__ */ new Map();
    function i(e2, n2) {
      return function(t2) {
        try {
          var i2, s2 = function(s3) {
            return i2 ? s3 : o(function() {
              var o2 = "data:application/javascript;base64," + btoa(n2);
              return Promise.resolve(t2.addModule(o2)).then(function() {
                r.set(e2, o2);
              });
            }, function() {
              throw new Error("Failed to load the " + e2 + " worklet module. Make sure the browser supports AudioWorklets.");
            });
          }, a2 = r.get(e2);
          if (a2) return Promise.resolve(t2.addModule(a2));
          var u2 = new Blob([n2], { type: "application/javascript" }), c2 = URL.createObjectURL(u2), l2 = o(function() {
            return Promise.resolve(t2.addModule(c2)).then(function() {
              r.set(e2, c2), i2 = 1;
            });
          }, function() {
            URL.revokeObjectURL(c2);
          });
          return Promise.resolve(l2 && l2.then ? l2.then(s2) : s2(l2));
        } catch (e3) {
          return Promise.reject(e3);
        }
      };
    }
    var s = i("raw-audio-processor", `
const BIAS = 0x84;
const CLIP = 32635;
const encodeTable = [
  0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,
  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
];

function encodeSample(sample) {
  let sign;
  let exponent;
  let mantissa;
  let muLawSample;
  sign = (sample >> 8) & 0x80;
  if (sign !== 0) sample = -sample;
  sample = sample + BIAS;
  if (sample > CLIP) sample = CLIP;
  exponent = encodeTable[(sample>>7) & 0xFF];
  mantissa = (sample >> (exponent+3)) & 0x0F;
  muLawSample = ~(sign | (exponent << 4) | mantissa);
  
  return muLawSample;
}

class RawAudioProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
              
    this.port.onmessage = ({ data }) => {
      switch (data.type) {
        case "setFormat":
          this.isMuted = false;
          this.buffer = []; // Initialize an empty buffer
          this.bufferSize = data.sampleRate / 4;
          this.format = data.format;

          if (globalThis.LibSampleRate && sampleRate !== data.sampleRate) {
            globalThis.LibSampleRate.create(1, sampleRate, data.sampleRate).then(resampler => {
              this.resampler = resampler;
            });
          }
          break;
        case "setMuted":
          this.isMuted = data.isMuted;
          break;
      }
    };
  }
  process(inputs) {
    if (!this.buffer) {
      return true;
    }
    
    const input = inputs[0]; // Get the first input node
    if (input.length > 0) {
      let channelData = input[0]; // Get the first channel's data

      // Resample the audio if necessary
      if (this.resampler) {
        channelData = this.resampler.full(channelData);
      }

      // Add channel data to the buffer
      this.buffer.push(...channelData);
      // Get max volume 
      let sum = 0.0;
      for (let i = 0; i < channelData.length; i++) {
        sum += channelData[i] * channelData[i];
      }
      const maxVolume = Math.sqrt(sum / channelData.length);
      // Check if buffer size has reached or exceeded the threshold
      if (this.buffer.length >= this.bufferSize) {
        const float32Array = this.isMuted 
          ? new Float32Array(this.buffer.length)
          : new Float32Array(this.buffer);

        let encodedArray = this.format === "ulaw"
          ? new Uint8Array(float32Array.length)
          : new Int16Array(float32Array.length);

        // Iterate through the Float32Array and convert each sample to PCM16
        for (let i = 0; i < float32Array.length; i++) {
          // Clamp the value to the range [-1, 1]
          let sample = Math.max(-1, Math.min(1, float32Array[i]));

          // Scale the sample to the range [-32768, 32767]
          let value = sample < 0 ? sample * 32768 : sample * 32767;
          if (this.format === "ulaw") {
            value = encodeSample(Math.round(value));
          }

          encodedArray[i] = value;
        }

        // Send the buffered data to the main script
        this.port.postMessage([encodedArray, maxVolume]);

        // Clear the buffer after sending
        this.buffer = [];
      }
    }
    return true; // Continue processing
  }
}
registerProcessor("raw-audio-processor", RawAudioProcessor);
`);
    function a() {
      return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
    }
    var u = /* @__PURE__ */ function() {
      function e2(e3, n3, t2, o2) {
        this.context = void 0, this.analyser = void 0, this.worklet = void 0, this.inputStream = void 0, this.context = e3, this.analyser = n3, this.worklet = t2, this.inputStream = o2;
      }
      e2.create = function(n3) {
        var t2 = n3.sampleRate, o2 = n3.format, r2 = n3.preferHeadphonesForIosDevices;
        try {
          var i2 = null, u2 = null;
          return Promise.resolve(function(n4, c2) {
            try {
              var l2 = function() {
                function n5() {
                  function n6() {
                    return Promise.resolve(s(i2.audioWorklet)).then(function() {
                      return Promise.resolve(navigator.mediaDevices.getUserMedia({ audio: c3 })).then(function(n7) {
                        var r4 = i2.createMediaStreamSource(u2 = n7), s2 = new AudioWorkletNode(i2, "raw-audio-processor");
                        return s2.port.postMessage({ type: "setFormat", format: o2, sampleRate: t2 }), r4.connect(a2), a2.connect(s2), Promise.resolve(i2.resume()).then(function() {
                          return new e2(i2, a2, s2, u2);
                        });
                      });
                    });
                  }
                  var r3 = navigator.mediaDevices.getSupportedConstraints().sampleRate, a2 = (i2 = new window.AudioContext(r3 ? { sampleRate: t2 } : {})).createAnalyser(), l4 = function() {
                    if (!r3) return Promise.resolve(i2.audioWorklet.addModule("https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js")).then(function() {
                    });
                  }();
                  return l4 && l4.then ? l4.then(n6) : n6();
                }
                var c3 = { sampleRate: { ideal: t2 }, echoCancellation: { ideal: true }, noiseSuppression: { ideal: true } }, l3 = function() {
                  if (a() && r2) return Promise.resolve(window.navigator.mediaDevices.enumerateDevices()).then(function(e3) {
                    var n6 = e3.find(function(e4) {
                      return "audioinput" === e4.kind && ["airpod", "headphone", "earphone"].find(function(n7) {
                        return e4.label.toLowerCase().includes(n7);
                      });
                    });
                    n6 && (c3.deviceId = { ideal: n6.deviceId });
                  });
                }();
                return l3 && l3.then ? l3.then(n5) : n5();
              }();
            } catch (e3) {
              return c2(e3);
            }
            return l2 && l2.then ? l2.then(void 0, c2) : l2;
          }(0, function(e3) {
            var n4, t3;
            throw null == (n4 = u2) || n4.getTracks().forEach(function(e4) {
              return e4.stop();
            }), null == (t3 = i2) || t3.close(), e3;
          }));
        } catch (e3) {
          return Promise.reject(e3);
        }
      };
      var n2 = e2.prototype;
      return n2.close = function() {
        try {
          return this.inputStream.getTracks().forEach(function(e3) {
            return e3.stop();
          }), Promise.resolve(this.context.close()).then(function() {
          });
        } catch (e3) {
          return Promise.reject(e3);
        }
      }, n2.setMuted = function(e3) {
        this.worklet.port.postMessage({ type: "setMuted", isMuted: e3 });
      }, e2;
    }(), c = i("audio-concat-processor", '\nconst decodeTable = [0,132,396,924,1980,4092,8316,16764];\n\nexport function decodeSample(muLawSample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let sample;\n  muLawSample = ~muLawSample;\n  sign = (muLawSample & 0x80);\n  exponent = (muLawSample >> 4) & 0x07;\n  mantissa = muLawSample & 0x0F;\n  sample = decodeTable[exponent] + (mantissa << (exponent+3));\n  if (sign !== 0) sample = -sample;\n\n  return sample;\n}\n\nclass AudioConcatProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.buffers = []; // Initialize an empty buffer\n    this.cursor = 0;\n    this.currentBuffer = null;\n    this.wasInterrupted = false;\n    this.finished = false;\n    \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case "setFormat":\n          this.format = data.format;\n          break;\n        case "buffer":\n          this.wasInterrupted = false;\n          this.buffers.push(\n            this.format === "ulaw"\n              ? new Uint8Array(data.buffer)\n              : new Int16Array(data.buffer)\n          );\n          break;\n        case "interrupt":\n          this.wasInterrupted = true;\n          break;\n        case "clearInterrupted":\n          if (this.wasInterrupted) {\n            this.wasInterrupted = false;\n            this.buffers = [];\n            this.currentBuffer = null;\n          }\n      }\n    };\n  }\n  process(_, outputs) {\n    let finished = false;\n    const output = outputs[0][0];\n    for (let i = 0; i < output.length; i++) {\n      if (!this.currentBuffer) {\n        if (this.buffers.length === 0) {\n          finished = true;\n          break;\n        }\n        this.currentBuffer = this.buffers.shift();\n        this.cursor = 0;\n      }\n\n      let value = this.currentBuffer[this.cursor];\n      if (this.format === "ulaw") {\n        value = decodeSample(value);\n      }\n      output[i] = value / 32768;\n      this.cursor++;\n\n      if (this.cursor >= this.currentBuffer.length) {\n        this.currentBuffer = null;\n      }\n    }\n\n    if (this.finished !== finished) {\n      this.finished = finished;\n      this.port.postMessage({ type: "process", finished });\n    }\n\n    return true; // Continue processing\n  }\n}\n\nregisterProcessor("audio-concat-processor", AudioConcatProcessor);\n'), l = /* @__PURE__ */ function() {
      function e2(e3, n2, t2, o2) {
        this.context = void 0, this.analyser = void 0, this.gain = void 0, this.worklet = void 0, this.context = e3, this.analyser = n2, this.gain = t2, this.worklet = o2;
      }
      return e2.create = function(n2) {
        var t2 = n2.sampleRate, o2 = n2.format;
        try {
          var r2 = null;
          return Promise.resolve(function(n3, i2) {
            try {
              var s2 = (a2 = (r2 = new AudioContext({ sampleRate: t2 })).createAnalyser(), (u2 = r2.createGain()).connect(a2), a2.connect(r2.destination), Promise.resolve(c(r2.audioWorklet)).then(function() {
                var n4 = new AudioWorkletNode(r2, "audio-concat-processor");
                return n4.port.postMessage({ type: "setFormat", format: o2 }), n4.connect(u2), Promise.resolve(r2.resume()).then(function() {
                  return new e2(r2, a2, u2, n4);
                });
              }));
            } catch (e3) {
              return i2(e3);
            }
            var a2, u2;
            return s2 && s2.then ? s2.then(void 0, i2) : s2;
          }(0, function(e3) {
            var n3;
            throw null == (n3 = r2) || n3.close(), e3;
          }));
        } catch (e3) {
          return Promise.reject(e3);
        }
      }, e2.prototype.close = function() {
        try {
          return Promise.resolve(this.context.close()).then(function() {
          });
        } catch (e3) {
          return Promise.reject(e3);
        }
      }, e2;
    }();
    function d(e2) {
      return !!e2.type;
    }
    var h = /* @__PURE__ */ function() {
      function e2(e3, n3, t2, o2) {
        var r2 = this;
        this.socket = void 0, this.conversationId = void 0, this.inputFormat = void 0, this.outputFormat = void 0, this.queue = [], this.disconnectionDetails = null, this.onDisconnectCallback = null, this.onMessageCallback = null, this.socket = e3, this.conversationId = n3, this.inputFormat = t2, this.outputFormat = o2, this.socket.addEventListener("error", function(e4) {
          setTimeout(function() {
            return r2.disconnect({ reason: "error", message: "The connection was closed due to a socket error.", context: e4 });
          }, 0);
        }), this.socket.addEventListener("close", function(e4) {
          r2.disconnect(1e3 === e4.code ? { reason: "agent", context: e4 } : { reason: "error", message: e4.reason || "The connection was closed by the server.", context: e4 });
        }), this.socket.addEventListener("message", function(e4) {
          try {
            var n4 = JSON.parse(e4.data);
            if (!d(n4)) return;
            r2.onMessageCallback ? r2.onMessageCallback(n4) : r2.queue.push(n4);
          } catch (e5) {
          }
        });
      }
      e2.create = function(n3) {
        try {
          var t2 = null;
          return Promise.resolve(function(o2, r2) {
            try {
              var i2 = (a2 = null != (s2 = n3.origin) ? s2 : "wss://api.elevenlabs.io", u2 = n3.signedUrl ? n3.signedUrl : a2 + "/v1/convai/conversation?agent_id=" + n3.agentId, c2 = ["convai"], n3.authorization && c2.push("bearer." + n3.authorization), t2 = new WebSocket(u2, c2), Promise.resolve(new Promise(function(e3, o3) {
                t2.addEventListener("open", function() {
                  var e4, o4, r3, i3, s3, a3 = { type: "conversation_initiation_client_data" };
                  n3.overrides && (a3.conversation_config_override = { agent: { prompt: null == (o4 = n3.overrides.agent) ? void 0 : o4.prompt, first_message: null == (r3 = n3.overrides.agent) ? void 0 : r3.firstMessage, language: null == (i3 = n3.overrides.agent) ? void 0 : i3.language }, tts: { voice_id: null == (s3 = n3.overrides.tts) ? void 0 : s3.voiceId } }), n3.customLlmExtraBody && (a3.custom_llm_extra_body = n3.customLlmExtraBody), n3.dynamicVariables && (a3.dynamic_variables = n3.dynamicVariables), null == (e4 = t2) || e4.send(JSON.stringify(a3));
                }, { once: true }), t2.addEventListener("error", function(e4) {
                  setTimeout(function() {
                    return o3(e4);
                  }, 0);
                }), t2.addEventListener("close", o3), t2.addEventListener("message", function(n4) {
                  var t3 = JSON.parse(n4.data);
                  d(t3) && ("conversation_initiation_metadata" === t3.type ? e3(t3.conversation_initiation_metadata_event) : console.warn("First received message is not conversation metadata."));
                }, { once: true });
              })).then(function(n4) {
                var o3 = n4.conversation_id, r3 = n4.agent_output_audio_format, i3 = n4.user_input_audio_format, s3 = f(null != i3 ? i3 : "pcm_16000"), a3 = f(r3);
                return new e2(t2, o3, s3, a3);
              }));
            } catch (e3) {
              return r2(e3);
            }
            var s2, a2, u2, c2;
            return i2 && i2.then ? i2.then(void 0, r2) : i2;
          }(0, function(e3) {
            var n4;
            throw null == (n4 = t2) || n4.close(), e3;
          }));
        } catch (e3) {
          return Promise.reject(e3);
        }
      };
      var n2 = e2.prototype;
      return n2.close = function() {
        this.socket.close();
      }, n2.sendMessage = function(e3) {
        this.socket.send(JSON.stringify(e3));
      }, n2.onMessage = function(e3) {
        this.onMessageCallback = e3, this.queue.forEach(e3), this.queue = [];
      }, n2.onDisconnect = function(e3) {
        this.onDisconnectCallback = e3, this.disconnectionDetails && e3(this.disconnectionDetails);
      }, n2.disconnect = function(e3) {
        var n3;
        this.disconnectionDetails || (this.disconnectionDetails = e3, null == (n3 = this.onDisconnectCallback) || n3.call(this, e3));
      }, e2;
    }();
    function f(e2) {
      var n2 = e2.split("_"), t2 = n2[0], o2 = n2[1];
      if (!["pcm", "ulaw"].includes(t2)) throw new Error("Invalid format: " + e2);
      var r2 = parseInt(o2);
      if (isNaN(r2)) throw new Error("Invalid sample rate: " + o2);
      return { format: t2, sampleRate: r2 };
    }
    function p(e2, n2) {
      try {
        var t2 = e2();
      } catch (e3) {
        return n2(e3);
      }
      return t2 && t2.then ? t2.then(void 0, n2) : t2;
    }
    var m = { clientTools: {} }, v = { onConnect: function() {
    }, onDebug: function() {
    }, onDisconnect: function() {
    }, onError: function() {
    }, onMessage: function() {
    }, onAudio: function() {
    }, onModeChange: function() {
    }, onStatusChange: function() {
    }, onCanSendFeedbackChange: function() {
    } };
    e.Conversation = /* @__PURE__ */ function() {
      function e2(e3, n2, o2, r2, i2) {
        var s2 = this, a2 = this, u2 = this;
        this.options = void 0, this.connection = void 0, this.input = void 0, this.output = void 0, this.wakeLock = void 0, this.lastInterruptTimestamp = 0, this.mode = "listening", this.status = "connecting", this.inputFrequencyData = void 0, this.outputFrequencyData = void 0, this.volume = 1, this.currentEventId = 1, this.lastFeedbackEventId = 1, this.canSendFeedback = false, this.endSession = function() {
          return u2.endSessionWithDetails({ reason: "user" });
        }, this.endSessionWithDetails = function(e4) {
          try {
            var n3 = function() {
              return s2.connection.close(), Promise.resolve(s2.input.close()).then(function() {
                return Promise.resolve(s2.output.close()).then(function() {
                  s2.updateStatus("disconnected"), s2.options.onDisconnect(e4);
                });
              });
            };
            if ("connected" !== s2.status && "connecting" !== s2.status) return Promise.resolve();
            s2.updateStatus("disconnecting");
            var t2 = p(function() {
              var e5;
              return Promise.resolve(null == (e5 = s2.wakeLock) ? void 0 : e5.release()).then(function() {
                s2.wakeLock = null;
              });
            }, function() {
            });
            return Promise.resolve(t2 && t2.then ? t2.then(n3) : n3());
          } catch (e5) {
            return Promise.reject(e5);
          }
        }, this.updateMode = function(e4) {
          e4 !== u2.mode && (u2.mode = e4, u2.options.onModeChange({ mode: e4 }));
        }, this.updateStatus = function(e4) {
          e4 !== u2.status && (u2.status = e4, u2.options.onStatusChange({ status: e4 }));
        }, this.updateCanSendFeedback = function() {
          var e4 = u2.currentEventId !== u2.lastFeedbackEventId;
          u2.canSendFeedback !== e4 && (u2.canSendFeedback = e4, u2.options.onCanSendFeedbackChange({ canSendFeedback: e4 }));
        }, this.onMessage = function(e4) {
          try {
            switch (e4.type) {
              case "interruption":
                return e4.interruption_event && (a2.lastInterruptTimestamp = e4.interruption_event.event_id), a2.fadeOutAudio(), Promise.resolve();
              case "agent_response":
                return a2.options.onMessage({ source: "ai", message: e4.agent_response_event.agent_response }), Promise.resolve();
              case "user_transcript":
                return a2.options.onMessage({ source: "user", message: e4.user_transcription_event.user_transcript }), Promise.resolve();
              case "internal_tentative_agent_response":
                return a2.options.onDebug({ type: "tentative_agent_response", response: e4.tentative_agent_response_internal_event.tentative_agent_response }), Promise.resolve();
              case "client_tool_call":
                return Promise.resolve(function() {
                  if (a2.options.clientTools.hasOwnProperty(e4.client_tool_call.tool_name)) {
                    var n3 = p(function() {
                      return Promise.resolve(a2.options.clientTools[e4.client_tool_call.tool_name](e4.client_tool_call.parameters)).then(function(n4) {
                        var t2 = "object" == typeof n4 ? JSON.stringify(n4) : String(n4);
                        a2.connection.sendMessage({ type: "client_tool_result", tool_call_id: e4.client_tool_call.tool_call_id, result: t2, is_error: false });
                      });
                    }, function(n4) {
                      a2.onError("Client tool execution failed with following error: " + (null == n4 ? void 0 : n4.message), { clientToolName: e4.client_tool_call.tool_name }), a2.connection.sendMessage({ type: "client_tool_result", tool_call_id: e4.client_tool_call.tool_call_id, result: "Client tool execution failed: " + (null == n4 ? void 0 : n4.message), is_error: true });
                    });
                    if (n3 && n3.then) return n3.then(function() {
                    });
                  } else {
                    if (a2.options.onUnhandledClientToolCall) return void a2.options.onUnhandledClientToolCall(e4.client_tool_call);
                    a2.onError("Client tool with name " + e4.client_tool_call.tool_name + " is not defined on client", { clientToolName: e4.client_tool_call.tool_name }), a2.connection.sendMessage({ type: "client_tool_result", tool_call_id: e4.client_tool_call.tool_call_id, result: "Client tool with name " + e4.client_tool_call.tool_name + " is not defined on client", is_error: true });
                  }
                }());
              case "audio":
                return a2.lastInterruptTimestamp <= e4.audio_event.event_id && (a2.options.onAudio(e4.audio_event.audio_base_64), a2.addAudioBase64Chunk(e4.audio_event.audio_base_64), a2.currentEventId = e4.audio_event.event_id, a2.updateCanSendFeedback(), a2.updateMode("speaking")), Promise.resolve();
              case "ping":
                return a2.connection.sendMessage({ type: "pong", event_id: e4.ping_event.event_id }), Promise.resolve();
              default:
                return a2.options.onDebug(e4), Promise.resolve();
            }
          } catch (e5) {
            return Promise.reject(e5);
          }
        }, this.onInputWorkletMessage = function(e4) {
          var n3, t2;
          "connected" === u2.status && u2.connection.sendMessage({ user_audio_chunk: (n3 = e4.data[0].buffer, t2 = new Uint8Array(n3), window.btoa(String.fromCharCode.apply(String, t2))) });
        }, this.onOutputWorkletMessage = function(e4) {
          var n3 = e4.data;
          "process" === n3.type && u2.updateMode(n3.finished ? "listening" : "speaking");
        }, this.addAudioBase64Chunk = function(e4) {
          u2.output.gain.gain.value = u2.volume, u2.output.worklet.port.postMessage({ type: "clearInterrupted" }), u2.output.worklet.port.postMessage({ type: "buffer", buffer: t(e4) });
        }, this.fadeOutAudio = function() {
          u2.updateMode("listening"), u2.output.worklet.port.postMessage({ type: "interrupt" }), u2.output.gain.gain.exponentialRampToValueAtTime(1e-4, u2.output.context.currentTime + 2), setTimeout(function() {
            u2.output.gain.gain.value = u2.volume, u2.output.worklet.port.postMessage({ type: "clearInterrupted" });
          }, 2e3);
        }, this.onError = function(e4, n3) {
          console.error(e4, n3), u2.options.onError(e4, n3);
        }, this.calculateVolume = function(e4) {
          if (0 === e4.length) return 0;
          for (var n3 = 0, t2 = 0; t2 < e4.length; t2++) n3 += e4[t2] / 255;
          return (n3 /= e4.length) < 0 ? 0 : n3 > 1 ? 1 : n3;
        }, this.getId = function() {
          return u2.connection.conversationId;
        }, this.isOpen = function() {
          return "connected" === u2.status;
        }, this.setVolume = function(e4) {
          u2.volume = e4.volume;
        }, this.setMicMuted = function(e4) {
          u2.input.setMuted(e4);
        }, this.getInputByteFrequencyData = function() {
          return null != u2.inputFrequencyData || (u2.inputFrequencyData = new Uint8Array(u2.input.analyser.frequencyBinCount)), u2.input.analyser.getByteFrequencyData(u2.inputFrequencyData), u2.inputFrequencyData;
        }, this.getOutputByteFrequencyData = function() {
          return null != u2.outputFrequencyData || (u2.outputFrequencyData = new Uint8Array(u2.output.analyser.frequencyBinCount)), u2.output.analyser.getByteFrequencyData(u2.outputFrequencyData), u2.outputFrequencyData;
        }, this.getInputVolume = function() {
          return u2.calculateVolume(u2.getInputByteFrequencyData());
        }, this.getOutputVolume = function() {
          return u2.calculateVolume(u2.getOutputByteFrequencyData());
        }, this.sendFeedback = function(e4) {
          u2.canSendFeedback ? (u2.connection.sendMessage({ type: "feedback", score: e4 ? "like" : "dislike", event_id: u2.currentEventId }), u2.lastFeedbackEventId = u2.currentEventId, u2.updateCanSendFeedback()) : console.warn(0 === u2.lastFeedbackEventId ? "Cannot send feedback: the conversation has not started yet." : "Cannot send feedback: feedback has already been sent for the current response.");
        }, this.sendContextualUpdate = function(e4) {
          u2.connection.sendMessage({ type: "contextual_update", text: e4 });
        }, this.sendUserMessage = function(e4) {
          u2.connection.sendMessage({ type: "user_message", text: e4 });
        }, this.sendUserActivity = function() {
          u2.connection.sendMessage({ type: "user_activity" });
        }, this.options = e3, this.connection = n2, this.input = o2, this.output = r2, this.wakeLock = i2, this.options.onConnect({ conversationId: n2.conversationId }), this.connection.onDisconnect(this.endSessionWithDetails), this.connection.onMessage(this.onMessage), this.input.worklet.port.onmessage = this.onInputWorkletMessage, this.output.worklet.port.onmessage = this.onOutputWorkletMessage, this.updateStatus("connected");
      }
      return e2.startSession = function(t2) {
        try {
          var o2 = function() {
            return p(function() {
              return Promise.resolve(navigator.mediaDevices.getUserMedia({ audio: true })).then(function(o3) {
                var p2;
                function m2() {
                  return Promise.resolve(h.create(t2)).then(function(o4) {
                    return s2 = o4, Promise.resolve(Promise.all([u.create(n({}, s2.inputFormat, { preferHeadphonesForIosDevices: t2.preferHeadphonesForIosDevices })), l.create(s2.outputFormat)])).then(function(n2) {
                      var t3;
                      return i2 = n2[0], c2 = n2[1], null == (t3 = d2) || t3.getTracks().forEach(function(e3) {
                        return e3.stop();
                      }), d2 = null, new e2(r2, s2, i2, c2, f2);
                    });
                  });
                }
                d2 = o3;
                var v2, g2 = null != (p2 = t2.connectionDelay) ? p2 : { default: 0, android: 3e3 }, y = g2.default;
                if (/android/i.test(navigator.userAgent)) y = null != (v2 = g2.android) ? v2 : y;
                else if (a()) {
                  var _;
                  y = null != (_ = g2.ios) ? _ : y;
                }
                var b = function() {
                  if (y > 0) return Promise.resolve(new Promise(function(e3) {
                    return setTimeout(e3, y);
                  })).then(function() {
                  });
                }();
                return b && b.then ? b.then(m2) : m2();
              });
            }, function(e3) {
              var n2, t3, o3;
              return r2.onStatusChange({ status: "disconnected" }), null == (n2 = d2) || n2.getTracks().forEach(function(e4) {
                return e4.stop();
              }), null == (t3 = s2) || t3.close(), Promise.resolve(null == (o3 = i2) ? void 0 : o3.close()).then(function() {
                var n3;
                return Promise.resolve(null == (n3 = c2) ? void 0 : n3.close()).then(function() {
                  function n4() {
                    throw e3;
                  }
                  var t4 = p(function() {
                    var e4;
                    return Promise.resolve(null == (e4 = f2) ? void 0 : e4.release()).then(function() {
                      f2 = null;
                    });
                  }, function() {
                  });
                  return t4 && t4.then ? t4.then(n4) : n4();
                });
              });
            });
          }, r2 = n({}, m, v, t2);
          r2.onStatusChange({ status: "connecting" }), r2.onCanSendFeedbackChange({ canSendFeedback: false });
          var i2 = null, s2 = null, c2 = null, d2 = null, f2 = null, g = function(e3) {
            if (null == (e3 = t2.useWakeLock) || e3) {
              var n2 = p(function() {
                return Promise.resolve(navigator.wakeLock.request("screen")).then(function(e4) {
                  f2 = e4;
                });
              }, function() {
              });
              if (n2 && n2.then) return n2.then(function() {
              });
            }
          }();
          return Promise.resolve(g && g.then ? g.then(o2) : o2());
        } catch (e3) {
          return Promise.reject(e3);
        }
      }, e2;
    }(), e.postOverallFeedback = function(e2, n2, t2) {
      return void 0 === t2 && (t2 = "https://api.elevenlabs.io"), fetch(t2 + "/v1/convai/conversations/" + e2 + "/feedback", { method: "POST", body: JSON.stringify({ feedback: n2 ? "like" : "dislike" }), headers: { "Content-Type": "application/json" } });
    };
  });
})();
